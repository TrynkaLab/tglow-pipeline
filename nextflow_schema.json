{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://raw.githubusercontent.com///nextflow_schema.json",
  "title": " pipeline parameters",
  "description": "",
  "type": "object",
  "$defs": {
    "pipeline": {
      "title": "Pipeline",
      "type": "object",
      "description": "",
      "default": "",
      "properties": {
        "rn_manifest": {
          "type": "string",
          "description": "Core manifest set bp_channels to none to not run basicpy set cp_cell_channel to none to not run cellpose set cp_nucl_channel to none to run cellpose without a nucleus channel If a registration manifest is provided, only reference plates will be run through cellpose <plate> <index_xml> <channels> <bp_channels> <cp_nucl_channel> <cp_cell_channel> <dc_channels> <dc_psfs> <mask_channels> <scale_factors>",
          "format": "file-path",
          "mimetype": "text/csv"
        },
        "rn_blacklist": {
          "type": "string",
          "description": "Well level manifest (blacklist), supply path to file. Specifying which wells to ignore. This is useful to deal with edgecases in a plate or single stain controls etc. you don't want to analyze. Leave at null to ignore. <plate> <well> plate1 A09 plate2 A09 plate2 D12",
          "format": "file-path",
          "mimetype": "text/csv"
        },
        "rn_control_list": {
          "type": "string",
          "description": "Control file to use to calculate plate offsets based on control cells for each channel <plate> <well> <channels> <name> plate1 A10 1,2,3 controlA plate1 B10 1,2,3 controlA plate1 C10 1,2,3 controlA plate1 D11 5,6,7 controlB plate1 D12 5,6,7 controlB",
          "format": "file-path",
          "mimetype": "text/csv"
        },
        "rn_manifest_well": {
          "type": "string",
          "description": "Well level manifest (whitelist) This is a file with <well> <plate> <pe xml> structure indicating which wells on which plates to run Set to null if auto generated from perkinelmer XML If not null, supply a list /path/to/plate1_manifest.csv,/path/to/plate2_manifest.csv,..."
        },
        "rn_manifest_registration": {
          "type": "string",
          "description": "Registration manifest This dictates which plates will be merged and registered. If left to null no merging or registration is performed",
          "format": "file-path",
          "mimetype": "text/csv"
        },
        "rn_image_dir": {
          "type": "string",
          "description": "Permanent cache for images [optional] Defaults to: ${rn_publish_dir}/images",
          "format": "directory-path"
        },
        "rn_decon_dir": {
          "type": "string",
          "description": "Permanent cache for deconvolutions [optional] Defaults to: ${rn_publish_dir}/decon",
          "format": "directory-path"
        },
        "rn_max_project": {
          "type": "boolean",
          "description": "Max project prior to running segmentation and cellprofiler Decon is still done in 3d, but results are saved as max projections."
        },
        "rn_hybrid": {
          "type": "boolean",
          "description": "Run in hybrid 2d/3d mode. Masks and decon run and saved in 3d but only cellprofiler is run using max projections. In true ignores rn_max_project. Must be true to enable demultiplexing of nuclear and non-nuclear signals."
        },
        "rn_wells": {
          "type": "string",
          "description": "Select only these wells, useful for testing [optional] comma separated string of well ids: A06,B19,C22"
        },
        "rn_scratch": {
          "type": "boolean",
          "default": true,
          "description": "Use scratch space for most workdir operations, which saves IO load on networked filesystems. But this makes debugging harder as tmp results are not available"
        },
        "rn_cache_images": {
          "type": "boolean",
          "default": true,
          "description": "Cache the final output images (flatfield, decon, demultiplexed, registered, scaled, max_projected) They are saved as plate/row/col/field.ome.tiff in CZYX with additional cycle channels sequentially added. If storage is a concern, disable this and enable rn_scratch to not save large intermediates. NOTE: When mode is hybrid or max project, the storage this generates will not be that bad, so it\u2019s enabled by default. NOTE: This must be true when running subcell, but as subcell only works with max projected images, the storage overhead should be ok NOTE: These are not directly compatible with cellprofiler when working in 3d as they are saved in .ome.tiff for pipeline compatibility, which CPR does not handle. Prior to running cellprofiler they are split up into <field><plate><well>_ch<channel>.tiff which is compatible with both 2d and 3d formats. Use this pattern to set up your pipeline."
        },
        "rn_manualscale": {
          "type": "string",
          "description": "Path to scaling_factors.txt with line formatted: <plate>_ch<channel>=<scale> <plate>_ch<channel>=<scale> <plate>_ch<channel>=<scale> Space separated Channels zero indexed <plate> is the reference plate <channel> after merging cycles <scale> factor by which channel in plate is divided",
          "format": "file-path",
          "mimetype": "text/plain"
        },
        "rn_scale_slope": {
          "type": "string",
          "description": "Path to scaling_<slope/bias>.txt with one line formatted: <plate>_ch<channel>=<slope/bias> <plate>_ch<channel>=<slope/bias> <plate>_ch<channel>=<slope/bias> Sets shape of sigmoid curve used to weigh scaling factors differently in intensity ranges. Background pixels remain unscaled, smooth transition scales foreground pixels. Pipeline supports only pre-calculated slope and bias, cannot auto-estimate. Must supply both slope and bias if used. If null, scaling_factors applied uniformly. Works with --rn_manualscale and --rn_autoscale.",
          "format": "file-path",
          "mimetype": "text/plain"
        },
        "rn_scale_bias": {
          "type": "string",
          "description": "See rn_scale_slope (must supply with rn_scale_slope if supplied)",
          "format": "file-path",
          "mimetype": "text/plain"
        },
        "rn_autoscale": {
          "type": "boolean",
          "description": "Automatically determine scaling factors based on all images in manifest (excluding blacklist) Overrides rn_manualscale Runs after dc_clip_max applied Waits till deconvolution queue empty No feature extraction jobs submitted until autoscale completes Interacts with rn_controllist so dynamic range is optimal after plate offset factors. If rn_controllist is provided, rn_autoscale is on by default."
        },
        "rn_autoscale_q1": {
          "type": "string",
          "default": "q99.9999",
          "description": "Controls value to scale to within an image (quantiles of pixels). Valid options: 'q0', 'q0.1', 'q1', 'q5', 'q25', 'q50', 'q75', 'q90', 'q99', 'q99.9', 'q99.99', 'q99.999', 'q99.9999', 'q99.99999', 'q100', 'mean' Not all options practically sensible, recommend not below q99."
        },
        "rn_autoscale_q2": {
          "type": "integer",
          "default": 95,
          "description": "Controls which quantile is taken across all images for chosen q1 Valid options: 0 - 1"
        },
        "rn_dummy_mode": {
          "type": "boolean",
          "description": "Generate plate offsets in dummy mode (returns all 1\u2019s for equal scaling, just for testing)",
          "hidden": true
        },
        "rn_threshold": {
          "type": "boolean",
          "description": "When calculating plate offsets, threshold channel images prior to calculating mean object intensities. Background regions ignored. Otsu threshold on whole image used."
        },
        "tg_conda_env": {
          "type": "string",
          "default": "/software/teamtrynka/installs/tglow",
          "description": "Tglow conda env path"
        }
      },
      "required": ["rn_manifest"]
    },
    "staging": {
      "title": "Staging",
      "type": "object",
      "description": "",
      "default": "",
      "properties": {
        "st_label": {
          "type": "string",
          "default": "small_img",
          "description": "Resource label for staging"
        }
      }
    },
    "flatfield": {
      "title": "Flatfield",
      "type": "object",
      "description": "",
      "default": "",
      "properties": {
        "bp_run": {
          "type": "boolean",
          "default": true,
          "description": "Run flatfield estimation or not. Overrides the manifest"
        },
        "bp_global_flatfield": {
          "type": "boolean",
          "description": "Fit one flatfield per plate-channel, or one global flatfield per channel shared among the plates of a cycle"
        },
        "bp_label": {
          "type": "string",
          "default": "himem",
          "description": "Resource label for flatfield estimation"
        },
        "bp_mode": {
          "type": "string",
          "default": "POLY",
          "description": "Mode, one of BASICPY, POLY or PE"
        },
        "bp_threshold": {
          "type": "boolean",
          "description": "Should images be multi-otsu thresholded prior to fitting. Two top tiers treated as foreground. Helpful in sparse images but can throw off valuation if strong flatfield not handled well or outliers exist. In BASICPY mode mask is supplied as fitting_weights to fit only actual signal avoiding background fitting. In POLY the polynomial is fit on foreground pixels only."
        },
        "bp_degree": {
          "type": "integer",
          "default": 0,
          "description": "Degree for polynomial (2-4 recommended). If <=0 special polynomial model used same as PE Harmony fits, else numpy.polynomial.polynomial.polyvander2d used to generate design matrix with all combinations of x^i*y^i. Higher degrees more likely to overfit."
        },
        "bp_channels": {
          "type": "string",
          "description": "Channels to fit basicpy models on, leave null to run all channels specified in manifest (recommended). To not run basicpy for a plate, set channels to \"none\". Otherwise specify [[<plate>,<channel>,<index_xml>],...] to override manifest."
        },
        "bp_nimg": {
          "type": "integer",
          "default": 200,
          "description": "Number of random images to read into memory. Sampled with replacement. If no other option specified, this is number of images flatfield is trained on."
        },
        "bp_nimg_test": {
          "type": "integer",
          "default": 100,
          "description": "Number of images for independent sampling used for testing flatfield. Set 0 to skip flatfield evaluation."
        },
        "bp_merge_n": {
          "type": "integer",
          "description": "Number of images to max project into a compound \u2014 nimg times. If >1 basicpy run on nimg images each compound of merge_n images. Set null to run vanilla basicpy with no merging. Useful if low density images and flatfields tend to background signal rather than foreground. Recommended bp_nimg=100 and bp_merge_n=50 starting point but mileage varies. WARNING: samples same images into different compounds so some overlapping."
        },
        "bp_pseudoreplicates": {
          "type": "integer",
          "description": "Pseudoreplicate in memory related to merge_n but instead of disk I/O only nimg images read then pseudoreplicate compound images of size merge_n made. Sampling with replacement and overlaps possible. Goal similar to merge_n but avoids major IO load. Recommended to set nimg high to reduce overlap."
        },
        "bp_pseudoreplicates_test": {
          "type": "integer",
          "description": "Same as bp_pseudoreplicates but for flatfield evaluation"
        },
        "bp_use_ridge": {
          "type": "boolean",
          "description": "Use ridge regression instead of OLS to fit polynomial. Uses RidgeCV and 10 fold CV to find optimal alpha"
        },
        "bp_all_planes": {
          "type": "boolean",
          "description": "Instead of randomly picking one plane for a stack, use all planes. Can cause issues with basicpy as it assumes random variation between images. When rn_max_project true all planes are read and max projected so not an issue. Not recommended."
        },
        "bp_autosegment": {
          "type": "boolean",
          "description": "Apply basicpy autosegment option, opposite of threshold, applies mask erosion. Not recommended, basicpy only."
        },
        "bp_no_tune": {
          "type": "boolean",
          "description": "Do not tune basicpy model. Not recommended, basicpy only."
        }
      }
    },
    "registration": {
      "title": "Registration",
      "type": "object",
      "description": "",
      "default": "",
      "properties": {
        "rg_mode": {
          "type": "string",
          "default": "CROSS",
          "description": "Mode use skimage phase cross correlation or pystackreg with translation. CROSS or STACKREG"
        },
        "rg_label": {
          "type": "string",
          "default": "small",
          "description": "Resource label for registration"
        },
        "rg_offset_x": {
          "type": "string",
          "description": "Offset in X. Positive shifts down (scipy.ndimage.shift convention)"
        },
        "rg_offset_y": {
          "type": "string",
          "description": "Offset in Y. Positive shifts down (scipy.ndimage.shift convention)"
        },
        "rg_eval": {
          "type": "boolean",
          "default": true,
          "description": "Evaluate registration results with pearson correlation between registration channels. Useful if many signals as images mostly noise. TODO: Threshold image first then correlate"
        }
      }
    },
    "deconvolution": {
      "title": "Deconvolution",
      "type": "object",
      "description": "",
      "default": "",
      "properties": {
        "dc_label": {
          "type": "string",
          "default": "gpu_normal",
          "description": "Resource label for deconvolution"
        },
        "dc_run": {
          "type": "boolean",
          "description": "Run deconvolution or not"
        },
        "dc_psfs": {
          "type": "string",
          "description": "Point spread functions used for deconvolution. Leave null to not run deconvolution, better specified in manifest"
        },
        "dc_niter": {
          "type": "integer",
          "default": 100,
          "description": "Number of iterations to run Richardson Lucy deconvolution for"
        },
        "dc_psf_crop_z": {
          "type": "integer",
          "description": "Number of planes around PSF center to use for decon. Defaults to all in PSF"
        },
        "dc_psf_subsample_z": {
          "type": "integer",
          "description": "Select every x planes starting from PSF center. Useful if PSF image has higher z resolution than actual image. For example PSF 100nm spacing and image 500nm spacing set this to 5. dc_psf_crop_z is applied after this."
        },
        "dc_mode": {
          "type": "string",
          "default": "clij2_nc",
          "description": "Implementation of Richardson Lucy to use. Options: clij2 - clij2-fft richardson_lucy clij2_nc - clij2-fft non circulant richardson_lucy rlf_cpu - RedLionFish CPU mode rlf_gpu - RedLionFish GPU mode RedLionFish not recommended when strong edges in data"
        },
        "dc_regularization": {
          "type": "number",
          "default": 0.0002,
          "description": "Regularization parameter for Richardson Lucy. Only used for clij2 and clij2_nc modes. Default recommended. See https://forum.image.sc/t/richardson-lucy-deconvolution-large-images/85325/7 and https://pubmed.ncbi.nlm.nih.gov/24436314/"
        },
        "dc_clip_max": {
          "type": "integer",
          "default": 327675,
          "description": "Pixel value clip after deconvolution in 32->16 bit conversion. new_intensity=round((intensity/dc_clip_max)65535) Default 565535=327675. Values lower preserved but may lose precision. Value above clip to 65535 in 16bit output. Set 65535 to clip everything outside 16bit range but preserve dynamic range. Set > 65535 to scale values down but keep dynamic range upper end. Keep consistent between runs to interpret intensities correctly."
        }
      }
    },
    "segmentation": {
      "title": "Segmentation",
      "type": "object",
      "description": "",
      "default": "",
      "properties": {
        "cp_run": {
          "type": "boolean",
          "default": true,
          "description": "Run cellpose or not (will stall the pipeline at downstream steps that need masks)"
        },
        "cp_label": {
          "type": "string",
          "default": "gpu_normal_plus",
          "description": "Resource label for cellpose"
        },
        "cp_cell_size": {
          "type": "integer",
          "default": 75,
          "description": "Estimated cell size for cellpose in pixels. Default is a reasonable estimates for T cells at 0.149um pixel size"
        },
        "cp_nucl_size": {
          "type": "integer",
          "default": 60,
          "description": "Estimated nucleus size for cellpose in pixels. Default is a reasonable estimates for T cells at 0.149um pixel size."
        },
        "cp_min_cell_area": {
          "type": "string",
          "description": "Cellpose min cell area in pixels. Minimal area of ROIs. If null defaults to \u03c0 (1/6th cp_cell_size)^2 for 2d or 4/3\u03c0 (1/6th cp_cell_size)^3 for 3d."
        },
        "cp_min_nucl_area": {
          "type": "string",
          "description": "Cellpose min nucleus area in pixels. Minimal area of ROIs. If null defaults to \u03c0 (1/6th cp_nucl_size)^2 for 2d or 4/3\u03c0 (1/6th cp_nucl_size)^3 for 3d."
        },
        "cp_model": {
          "type": "string",
          "default": "cyto2",
          "description": "Cellpose model. util built on cyto2 model and if possible will use nucleus channel. Other models should work in principle."
        },
        "cp_dont_use_nucl_for_declump": {
          "type": "boolean",
          "description": "Fit nucleus mask but do not use nuclei to declump objects in mask creation."
        },
        "cp_cell_power": {
          "type": "string",
          "hidden": true,
          "description": "Raise cell images to power then scale. Deprecated/experimental. Soft thresholding if cellpose fits masks too strongly to noise. Option if tweaking cellprob threshold or post-processing insufficient."
        },
        "cp_nucl_power": {
          "type": "string",
          "hidden": true,
          "description": "Raise nucleus images to power then scale. Deprecated/experimental. Soft thresholding if cellpose fits masks too strongly to noise. Option if tweaking cellprob threshold or post-processing insufficient."
        },
        "cp_downsample": {
          "type": "number",
          "description": "Downsample images in YX prior to running cellpose. Scales diameter, anisotropy, min cell area, min nucl area to match. Improves speed at cost of mask resolution. Masks scaled up by nearest neighbour interpolation. Recommended integer values producing whole number in YX, 2 is good."
        },
        "cp_dont_post_process": {
          "type": "boolean",
          "default": true,
          "description": "To not post process masks in 3d mode set true. In 3d some post-processing on nuclei applied: local otsu thresholding, hole closing, mask multiplied with cellpose masks to contain region with signal. Prevents incorrect masks due to z-bleedover from PSF residual signal. Deprecated/experimental.",
          "hidden": true
        },
        "cp_cell_flow_thresh": {
          "type": "number",
          "default": 0.4,
          "description": "Cellpose flow threshold for cells. See cellpose docs."
        },
        "cp_nucl_flow_thresh": {
          "type": "number",
          "default": 0.4,
          "description": "Cellpose flow threshold for nuclei. See cellpose docs."
        },
        "cp_cell_prob_threshold": {
          "type": "integer",
          "default": 0,
          "description": "Cellpose cellprob threshold for cells. Between -6 and 6. Higher is tighter masks, lower looser masks. See cellpose docs for details."
        },
        "cp_nucl_prob_threshold": {
          "type": "integer",
          "default": 0,
          "description": "Cellpose cellprob threshold for nuclei. Between -6 and 6. Higher is tighter masks, lower looser masks. See cellpose docs for details."
        },
        "rg_plot": {
          "type": "boolean",
          "default": true,
          "description": "Run only if registration manifest provided. Make before/after images of registration results"
        }
      }
    },
    "cellprofiler": {
      "title": "Cellprofiler",
      "type": "object",
      "description": "",
      "default": "",
      "properties": {
        "cpr_label": {
          "type": "string",
          "default": "normal"
        },
        "cpr_conda_env": {
          "type": "string",
          "default": "/software/teamtrynka/installs/cellprofiler"
        },
        "cpr_plugins": {
          "type": "string",
          "default": "/Users/ob7/Documents/projects/tglow-pipeline/bin/cellprofiler/plugins"
        },
        "cpr_run": {
          "type": "boolean"
        },
        "cpr_pipeline_2d": {
          "type": "string"
        },
        "cpr_pipeline_3d": {
          "type": "string"
        },
        "cpr_no_zip": {
          "type": "boolean"
        }
      }
    },
    "subcell": {
      "title": "SubCell",
      "type": "object",
      "description": "",
      "default": "",
      "properties": {
        "sc_label": {
          "type": "string",
          "default": "gpu_short",
          "description": "Resource label for subcell"
        },
        "sc_gpu": {
          "type": "boolean",
          "default": true,
          "description": "Should GPU be used, make sure to set sc_label to gpu_<x>"
        },
        "sc_dont_mask": {
          "type": "boolean",
          "description": "Should the cell crops not be masked by the cell object prior to embedding"
        },
        "sc_conda_env": {
          "type": "string",
          "default": "/software/teamtrynka/installs/subcell",
          "description": "Subcell conda env path"
        },
        "sc_dl_conda_env": {
          "type": "string",
          "default": "/software/teamtrynka/installs/subcell_model_dl",
          "description": "Subcell model download conda env path"
        },
        "sc_model_ref_channels": {
          "type": "string",
          "default": "rybg",
          "description": "Subcell model reference channels string like \"rybg\""
        },
        "sc_model": {
          "type": "string",
          "default": "mae_contrast_supcon_model",
          "description": "Subcell model string like \"mae_contrast_supcon_model\""
        },
        "sc_channels": {
          "type": "string",
          "description": "Channels to find localization for should be string '<name>=<channel> <name>=<channel>'"
        },
        "sc_nucl": {
          "type": "integer",
          "description": "Nucleus channel"
        },
        "sc_tub": {
          "type": "integer",
          "description": "Tubulin channel"
        },
        "sc_er": {
          "type": "integer",
          "description": "Endoplasmic reticulum channel"
        },
        "sc_scale": {
          "type": "number",
          "default": 1.8625,
          "description": "Scale factor to get pixel size to 80nm. In Phenix 1px=149nm at 40x, so sc_scale=149/80. TODO set properly using physical pixel size attribute if available"
        }
      }
    }
  },
  "allOf": [
    {
      "$ref": "#/$defs/pipeline"
    },
    {
      "$ref": "#/$defs/staging"
    },
    {
      "$ref": "#/$defs/flatfield"
    },
    {
      "$ref": "#/$defs/registration"
    },
    {
      "$ref": "#/$defs/deconvolution"
    },
    {
      "$ref": "#/$defs/segmentation"
    },
    {
      "$ref": "#/$defs/cellprofiler"
    },
    {
      "$ref": "#/$defs/subcell"
    }
  ]
}
